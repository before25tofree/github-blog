## 进程简述
  进程是操作系统的一个核心概念。每个进程都有自己唯一的标识：进程ID，也有自己的生命周期。分别介绍进程ID、进程的层次，以及进程生命周期内的各个阶段
### 进程 ID
  Linux下每个进程都会有一个非负整数表示的唯一进程ID，简称pid。Linux提供了getpid函数来获取进程的pid，同时提供了getppid来获取父进程的pid。每个进程都有自己的父进程，父进程又会有自己的父进程，最终都会追溯到1号进程即init进程。这就决定了操作系统上所有的进程必然会组成树状结构，就像一个家族的家谱一样。可以通过pstree的命令来查看进程的家族树。
  procfs文件系统会在/proc下为每个进程创建一个目录，名字是该进程的pid。目录下有很多的文件，用于记录进程的运行情况和统计信息等，
### 进程的层次
  每个进程都有父进程，父进程也有父进程，这就形成了一个以init进程为根的家族树。除此以外，进程还有其他层次的关系：进程、进程组和会话。
  进程组和会话在进程之间形成了两级的层次：进程组是一组相关进程组的集合，会话是一组相关进程组的集合。
### 进程创建之fork()
  Linux系统下，进程可以调用fork函数来创建新的进程为子进程。
  与普通函数不同，fork函数会返回两次。fork失败会返回-1。
### fork之后父子进程的内存关系
  fork之后的子进程完全拷贝了父进程的地址空间，包括栈、堆、代码段等。
  子进程和父进程执行一模一样的代码的情形比较少见。Linux提供了exexve系统调用之上，glibc提供了exec系列函数。这个系列函数会丢弃现存的程序代码段，并构建新的数据段、栈及堆。调用fork之后，子进程几乎总是通过调用exec系列函数，来执行新的程序。在这种背景下，fork时子进程完全拷贝父进程的数据段、栈和堆的做法是不明智的，因为接下来的exec系列函数会毫不留情地抛弃刚刚辛苦拷贝的内存。为了解决这个问题，Linux引入了写时拷贝(copy-on-write)的技术。
  写时拷贝是指子进程的页表项指向父进程相同的物理内存页，这样只拷贝父进程的页表项就可以了，当然要把这些页面标记成只读。如果父进程都不修改内存的内容，大家便相安无事，公用一份物理内存页。但是一旦父子进程中有任何一方尝试修改，就会引发缺页异常。此时，内核会尝试为该页面创建一个新的物理页面，并将内容真正的复制到新的物理页面中，让父子进程真正的各自拥有自己的物理内存页，然后将页表上对应的表项标记为可写。
  对于没有修改的页面，内核并没有真正的复制物理内存页，仅仅是复制了父进程的页表。这种机制的引入提升了fork的性能，从而使得内核可以快速的创建一个新的进程。
