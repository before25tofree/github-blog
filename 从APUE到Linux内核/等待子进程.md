## 等待子进程
### 僵尸进程
        进程就像一个生命体，通过fork（）函数，子进程呱呱坠地。有
    的子进程子承父业，继续执行与父进程一样的程序（相同的代码
    段，尽管可能是不同的程序分支），有的子进程则比较叛逆，通过
    exec离家出走，走向与父进程完全不同的道路。
        令人悲伤的是，如同所有的生命体一样，进程也会消亡。进程
    退出时会进行内核清理，基本就是释放进程所有的资源，这些资源
    包括内存资源、文件资源、信号量资源、共享内存资源，或者引用
    计数减一，或者彻底释放。不过，进程的退出其实并没有将所有的
    资源完全释放，仍保留了少量的资源，比如进程的PID依然被占用
    着，不可被系统分配。此时的进程不可运行，事实上也没有地址空
    间让其运行，进程进入僵尸状态。
        为什么进程退出之后不将所有的资源释放，从此灰飞烟灭，一
    了百了，反而非要保留少量资源，进入僵尸状态呢？看看僵尸进程
    依然占有的系统资源，我们就能获得答案。僵尸进程依然保留的资
    源有进程控制块task_struct、内核栈等。这些资源不释放是为了提供
    一些重要的信息，比如进程为何退出，是收到信号退出还是正常退
    出，进程退出码是多少，进程一共消耗了多少系统CPU时间，多少
    用户CPU时间，收到了多少信号，发生了多少次上下文切换，最大
    内存驻留集是多少，产生多少缺页中断？等等。这些信息，就像墓
    志铭，总结了进程的一生。如果没有这个僵尸状态，进程的这些信
    息也会随之流逝，系统也将再也没有机会获知该进程的相关信息
    了。因此进程退出后，会保留少量的资源，等待父进程前来收集这
    些信息。一旦父进程收集了这些信息之后（通过调用下面提到的
    wait/waitpid等函数），这些残存的资源完成了它的使命，就可以释
    放了，进程就脱离僵尸状态，彻底消失了。
### 从上面的讨论可以得出
        制造一个僵尸进程是一件很容易的
    事情，只要父进程调用fork创建子进程，子进程退出后，父进程如果
    不调用wait或waitpid来获取子进程的退出信息，子进程就会沦为僵
    尸进程
## 等待子进程之wait（）
        Linux提供了wait（）函数来获取子进程的退出状态：
    include <sys/wait.h>
    pid_t wait(int *status);
        成功时，返回已退出子进程的进程ID；失败时，则返回-1并设
    置errno，常见的errno及说明见表4-3。
        表4-3 wait函数的出错情况
        注意父子进程是两个进程，子进程退出和父进程调用wait（）函
    数来获取子进程的退出状态在时间上是独立的事件，因此会出现以
    下两种情况：
        ·子进程先退出，父进程后调用wait（）函数。
        ·父进程先调用wait（）函数，子进程后退出。
    对于第一种情况，子进程几乎已经销毁了自己所有的资源，只
    留下少量的信息，苦苦等待父进程来“收尸”
    。当父进程调用wait（）
    函数的时候，苦守寒窑十八载的子进程终于等到了父进程来“收
    尸”，这种情况下，父进程获取到子进程的状态信息，wait函数立刻
    返回。
        对于第二种情况，父进程先调用wait（）函数，调用时并无子进
    程退出，该函数调用就会陷入阻塞状态，直到某个子进程退出。
    wait（）函数等待的是任意一个子进程，任何一个子进程退出，
    都可以让其返回。当多个子进程都处于僵尸状态，wait（）函数获取
    到其中一个子进程的信息后立刻返回。由于wait（）函数不会接受
    pid_t类型的入参，所以它无法明确地等待特定的子进程。
    一个进程如何等待所有的子进程退出呢？wait（）函数返回有
    三种可能性：
        ·等到了子进程退出，获取其退出信息，返回子进程的进程ID。
        ·等待过程中，收到了信号，信号打断了系统调用，并且注册信
    号处理函数时并没有设置SA_RESTART标志位，系统调用不会被重
    启，wait（）函数返回-1，并且将errno设置为EINTR。
    ·已经成功地等待了所有子进程，没有子进程的退出信息需要
    接收，在这种情况下，wait（）函数返回-1，errno为ECHILD。
## 等待子进程之waitpid（）
    waitpid（）函数接口如下：
    #include <sys/wait.h>
    pid_t waitpid(pid_t pid, int *status, int options);
        先说说waitpid（）与wait（）函数相同的地方：
        ·返回值的含义相同，都是终止子进程或因信号停止或因信号
    恢复而执行的子进程的进程ID。
        ·status的含义相同，都是用来记录子进程的相关事件，后面一
    节将会详细介绍。
        接下来介绍waitpid（）函数特有的功能。
        其第一个参数是pid_t类型，有了此值，不难看出waitpid函数肯
    定具备了精确打击的能力。waitpid函数可以明确指定要等待哪一个
    子进程的退出（以及停止和恢复执行）。事实上，扩展的功能不仅仅
    如此：
        ·pid＞0：表示等待进程ID为pid的子进程，也就是上文提到的精
    确打击的对象。
        ·pid＝0：表示等待与调用进程同一个进程组的任意子进程；因
    为子进程可以设置自己的进程组，所以某些子进程不一定和父进程
    归属于同一个进程组，这样的子进程，waitpid函数就毫不关心了。
    ·pid＝-1：表示等待任意子进程，同wait类似。waitpid（-1，
    &status，0）与wait（&status）完全等价。
        ·pid＜-1：等待所有子进程中，进程组ID与pid绝对值相等的所
    有子进程。
        内核之中，wait函数和waitpid函数调用的都是wait4系统调用。
    下面是wait4系统调用的实现。函数的中间部分，根据pid的正负或
    是否为0和-1来定义wait_opts类型的变量wo，后面会根据wo来控制
    到底关心哪些进程的事件。
