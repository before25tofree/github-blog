## fork之后父子进程的内存关系

- fork之后的子进程完全拷贝了父进程的地址空间，包括栈、堆、代码段等。
  
- Linux提供了execve系统调用，构建在该系统调用之上，glibc提供了exec系列函数。这个系列函数会丢弃现存的程序代码段，并构建新的数据段、栈及堆。调用fork之后，子进程几乎总是通过调用exec系列函数，来执行新的程序。
  
  在这种背景下，fork时子进程完全拷贝父进程的数据段、栈和堆的做法是不明智的，因为接下来的exec系列函数会毫不留情的抛弃刚刚辛苦拷贝的内存，为了解决这个问题，
  Linux引入了写时拷贝的技术。
  
  写时拷贝是指子进程的页表项指向与父进程相同的物理内存页，这样拷贝父进程的页表项就可以了，当然要把这些页面标记成只读。如果父子进程都不修改内存的内容，大
  家便相安无事，公用一份物理内存页。但是一旦父子进程中有任何一方尝试修改，就会引发缺页异常。此时，内核会尝试为该页面创建一个新的物理页面，并将内容真正的
  复制到新的物理页面中，让父子进程真正的各自拥有自己的物理内存页，然后将页表中对应的表项标记为可写。
  
  对于没有修改的页面，内核并没有真正的复制物理内存页，仅仅是复制了父进程的页表。这种机制的引入提升了fork的性能，从而使内核可以快速的创建一个新的进程。
  
### fork之后父子进程与文件的关系

  执行fork函数，内核会复制父进程所有的文件描述符。对于父进程打开的所有的文件，子进程也是可以操作的。那么父子进程同时操作一个文件是并行不驳，还是互相影响
  的呢？
  
  下面可以通过对一个例子的讨论来说明这个问题。read函数并没有将偏移量作为参数传入，但是每次调用read函数或write函数时，却能够接着上次读写的位置继续读写。
  原因是内核已经将偏移量的信息记录在于文件描述符相关的数据结构中了。那么问题来了，父子进程是公用一个文件偏移量还是各自有各自的文件偏移量呢？
  
#### 测试实验得知：

  《Linux内核设计与实现》：父子进程之间拷贝的是struct file的指针，而不是struct file的实例，父子进程的struct file类型指针，都指向同一个struct file
  实例。fork之后，父子进程的文件描述符，即struct file类型指针指向同一个struct file实例。文件偏移量保存在struct file中，便不难理解父子进程是如何共享文
  件偏移量的了，那是因为父子进程的指针都指向了同一个struct file结构体。
	
