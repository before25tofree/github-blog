## 读写锁
很多时候，对共享变量的访问有以下特点：大多数情况下线程**只是读取共享变量的值**，并不修改，只有**极少数**情况下，线程才会真正地修改共享变量的值。

对于这种情况，读请求之间之间是无需同步的，他们之间的并发访问是安全的。但是必须互斥写请求和其他读请求。

这种情况在实际中是存在的，比如配置项。大多数时间内，配置是不会发生变化的，偶尔会出现修改配置的情况。如果使用互斥量，完全阻止读请求并发，则会造成性能的损失。

处于这种考虑，POSIX引入了读写锁。

## 读写锁的接口
### 1.创建和销毁读写锁
NTPL提供了**pthread_rwlock_t**类型来表示读写锁。和互斥量一样，它也提供了两种初始化(静态和动态两种)的方法：
```
#include <pthread.h>
int pthread_rwlock_init(pthread_rwlock_t *rwlock,
const pthread_rwlockattr_t *attr);
int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
pthread_rwlock_t rwlock=PTHREAD_RWLOCK_INITIALIZER;
```
对于静态变量，可以采用PTHREAD_RWLOCK_INITIALIZER赋值的方式初始化，对于动态分配的读写锁，或者非默认属性的读写锁，需要用pthread_rwlock_init函数进行初始化。如果第二个属性的参数为NULL，那么采用默认属性。

                  读写锁的默认属性
| 属性       |                值                   |     说明          |
| :--------: | :---------------------------------: | :---------------: |
| 竞争范围   |        PTHREAD_PROCESS_PRIVATE      |  进程内部竞争读写锁 |
| 策略       |   PTHREAD_RWLOCK_PREFER_READER_NP   |  读者优先          |

从表面上看，读写锁介绍到此处就可以了，其实不然，读写锁是两种类型的锁，当它们都存在时，它们之间的竞争关系如何？如果同时到来一大波读锁和写锁请求，它们之间的影响又有什么特点？事实上这些是由读写锁的策略决定的。

## 读写锁的竞争策略
读写锁的属性是pthread_rwlockattr_t类型，属性中有两个部分：lockkind和pshared。

所谓lockkind，表示读写锁表现出什么样的行为艺术。对于读写锁，目前有两种策略，一是读者优先，一是读者优先。

glibc引入了如下接口来查询和改变读写锁的类型：
```
int pthread_rwlockattr_getkind_np(const pthread_rwlockattr_t * attr, int * pref);
int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t * attr, int * pref);
```
其中，读写锁类型的可能值有如下几种：
```
enum
{
PTHREAD_RWLOCK_PREFER_READER_NP, //读者优先
PTHREAD_RWLOCK_PREFER_WRITER_NP, //很唬人，但是也是读者优先
PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP, //写者优先
PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
```
可以看到，只有PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP是写者优先，其他一律都是读者优先。读写锁的默认行为是读者优先。

## 那么什么是读者优先呢？

如果当前锁的状态是读锁，并存在写锁请求被阻塞，那么在写锁后面到来的读锁请求该如何处理就成为了问题的关键。

如果在写锁请求后面到来的读锁请求不被写锁请求阻塞，就可以立即响应，写锁的下场可能会比较悲惨。如果读锁请求前仆后继源源不断地到来，只要有一个读锁没完成，写锁就没分。这就是所谓的读者优先，总结来就是：读锁的优先级高于写锁的优先级。

较早到的写锁请求容易被饿死。

## 那么什么是写着优先呢?

所谓写者优先是指，如果当前是读锁，有很多线程在共享读锁，这是允许的，但是一旦线程申请写锁，在写锁请求后面到来的读锁请求就会统统被阻塞，不能先于写请求拿到锁。

glibc是如何做到这点的？如下：

变量                    |                  说明
:----------------------|:----------------------------------------------------------------
__lock                  |    管理读写锁全局竞争的锁，无论是读锁写锁还是解锁，都会互斥
__writer                |    写锁持有者的线程ID，如果为0则表示当前无线程持有写锁
__nr_readers            |     读锁持有线程的个数
__nr_readers_queued     |     读锁的派对等待线程的个数
__nr_writers_queued     |     写锁的排队等待线程的个数

无论是申请读锁还是申请写锁，还是解锁，都至少会做一次全局互斥锁(对应__lock)的加锁和解锁，若不考虑阻塞，蛋蛋考虑操作本身的开销，读写锁的加解锁开销是互斥锁的两倍。当然，函数结束前或进入阻塞之前，会将全局的互斥锁释放。

**对于读锁请求**而言，如果：

1. 无线程持有写锁，即__writer==0

2. 采用的是读者优先策略或没有写锁的等待者(__nr_writers_queued==0)

当满足这两个条件时，读锁请求都可以立即获得读锁，返回之前执行__nr_readers++，表示增加了一个线程占有读锁。

不满足的话，则执行__nr_readers_queued++,表示增加一个读锁等待者，然后调用futex，陷入阻塞。醒来之后，会执行__nr_readers_queued--,然后再次判断是否同时满足条件1和2

**对于写锁请求**而言，如果：

1. 无线程持有写锁，即__writer==0

2. 没有线程持有读锁，即__nr_readers==0

只要满足上述条件，就会立刻拿到写锁，将__writer置为线程的ID(调度域)

如果不满足，那么执行__nr_writers_queued++,表示增加一个写锁等待者线程，然后执行futex陷入等待。醒来后，先执行__nr_writers_queued--,然后重新判断条件1和2。

**对于解锁而言**，如果当前锁是写锁，则执行如下操作：

1. 执行__writer=0,表示释放写锁

2. 根据__nr_writers_queued判断有没有写锁等待者，如果有则唤醒一个写锁等待者

**如果没有写锁等待者**，则判断有没有读锁等待者；如果有，则将所有的读锁等待者一起唤醒。

如果当前锁是读锁，则执行如下操作：

1. 执行__nr_readers--,表示读锁占有者少了一个

2. 判断__nr_readers是否等于0，是的话则表示自己是最后一个读锁占有者，需要唤醒写锁等待者或者读锁等待者：

- 根据__nr_writers_queued判断是否存在写锁等待者，若有，则唤醒一个写锁等待线程
- 如果没有写锁等待者，判断是否存在读锁等待者，若有，则唤醒所有的读锁等待者

从上面的流程可以看出，写者优先也存在自私的倾向，因为写锁解锁的时候，优先去解锁写锁等待者，写锁等待者优先被解锁，也就意味着如果写锁请求一直存在的情况下，读锁请求将会出现长时间的饥饿状态。

### 读写锁总结
通过上面的分析可以看到，如果存在大量的读写请求，竞争非常激烈的条件下，读写锁存在很大的惯性，在不同的优先策略下，都有可能产生大量读或写请求的饥饿。

那么能否实现一款公平的读写锁呢？答案是肯定的。

从宏观意义上看，读写锁要比互斥量并发性好，因为读写锁在更多的时间区域内允许并发。

当然读写锁并不是完美的，互斥锁也有其存在的必要。读写锁会有如下的短处。

> ·性能：如果临界区比较大，读写锁高并发的优势就会显现出
> 来，但是如果临界区非常小，读写锁的性能短板就会暴露出来。由
> 于读写锁无论是加锁还是解锁，首先都会执行互斥操作，加上读写
> 锁还需要维护当前读者线程的个数、写锁等待线程的个数、读锁等
> 待线程的个数，因此这就决定了读写锁的开销不会小于互斥量。

> ·饿死：互斥量虽然不是绝对意义上的公正，但是线程不会饿
> 死。但是如上一小节的讨论，读者优先的策略下，写线程可能会饿
> 死。写者优先的情况下，读线程可能会饿死。

> ·死锁：读锁是可重入的，这就可能会引发死锁。考虑如下场
> 景，读写锁采用写者优先的策略，A线程已经持有读锁，B线程申请
> 了写锁，正处于等待状态，而持有读锁的A线程再次申请读锁，就
> 会发生死锁。

**比较适合读写锁的场景是：临界区的大小比较可观，绝大多数情况下是读，只有非常少的写**
