## spinlock
自旋锁是专为防止多处理器并发而引入的一种锁，它在内核中大量应用于中断处理部分。自旋锁最多只能被一个内核任务持有，如果一个内核任务试图请求一个已经被争用的自旋锁，那么这个任务就会一直进行忙循环——旋转——等待锁重新可用。

要是锁未被争用，请求它的内核任务便能立即得到它并且继续执行。自旋锁可以在任何时刻防止多于一个内核任务同时进入临界区，因此这种锁可有效地避免多处理器上并发运行的内核任务竞争共享资源。

事实上，自旋锁的初衷就是：在短期内进行轻量级的锁定。一个进程去获取被争用的自旋锁时，请求它的线程在等待锁重新可用的期间进行自选(特别的浪费处理器时间)，所以自旋锁不应该被持有时间过长(等待时cpu被独占无法调度)。如果需要长时间锁定的话，最好使用信号量(睡眠，cpu资源可出让)。

简单的说，自旋锁在内核中主要来防止多处理器中并发访问临界区，防止内核抢占造成的竞争。另外自旋锁不允许任务睡眠(持有自旋锁的任务睡眠可能会造成自死锁——因为睡眠可能会造成持有锁的内核任务被重新调度，而再次申请自己已持有的锁)，它能够在中断上下文中用

死锁：假设一个或多个内核任务和一个或多个资源，每个内核都在等待其中的一个资源，但所有的资源都被占用了。这便会发生所有内核任务都在相互等待，但是它们永远不会释放已经占有的资源，于是任何内核任务都无法获得所需要的资源，无法继续运行，这便意味着死锁产生了。自死锁死锁是说自己占有了某个资源，然后自己又申请自己占有的资源，显然死锁。

spinlock特性：
防止多处理器并发访问临界区，
1、非睡眠
2、忙等
3、短期加锁
4、适合中断上下文
5、多处理器

## 信号量
Linux中的信号量是一种睡眠锁。如果有一个任务试图获得一个已经被持有的信号量时，信号量会将其推入等待队列，然后让其睡眠。这时处理器获得自由去执行其他代码。当持有信号量的进程将信号量释放后，在等待队列中的一个任务将被唤醒，从而便可以获得这个信号量。

信号量的睡眠特性，使得信号量适用于锁会被长时间持有的情况；只能在进程上下文中使用，因为中断上下文中是不能被调度的；另外带代码持有信号量时，不可以再持有自旋锁。

## 互斥量
1.互斥量用于线程的互斥，信号量用于线程的同步
这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别

互斥：
是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排他性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的

同步：
是指在互斥的基础上，通过其他机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源

2.互斥量只能为0/1，信号量可以为非负整数
也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。

3.互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。
特性：
1、睡眠
2、必须进程上下文(可调度)
3、长期加锁

## 信号量和自旋锁的区别
虽然听起来两者之间的使用条件复杂，其实在实际使用中信号量和自旋锁：
如果代码需要睡眠——这往往是发生在和用户空间同步时——使用信号量时唯一的选择。由于不受睡眠的限制，使用信号量通常来说更加简单一些。
如果需要在自旋锁和信号量中做选择，应该取决于锁持有的时间长短。理想情况是所有的锁都应该尽可能的被持有短，但是如果锁的持有时间较长的话，使用信号量是更好的选择。
另外，信号量不同于自旋锁，它不会关闭内核抢占，所以持有信号量的代码可以被抢占。这意味着信号量不会对影响调度反应时间带来负面影响。
## 自旋锁和信号量的选择
| 需求          | 建议的加锁方法 |
| :---------------: | :----------------: |
| 低开销加锁     | 优先使用自旋锁 |
| 短期锁定       | 优先使用自旋锁  |
| 长期加锁       | 优先使用信号量 |
| 中断上下文中加锁 | 使用自旋锁    |
| 持有锁是需要睡眠、调度| 使用信号量 |

spinlock mutex语义上是一样的，都是对一临界区加锁保护，区别是mutex得不到锁会睡眠，因此不能在中断上下文中使用。
另外，解锁的一定是上锁的那个。最重要的就是只有spinlock可以用在中断上下文中。

至于wait_queue，不是同步手段，是内核管理sleeping进程的一种手段

### 什么是等待队列？

在软件开发中任务经常由于某种条件没有得到满足而不得不进入睡眠状态，然后等待条件得到满足的时候在继续运行，进入运行状态。这种需求需要等待队列机制的支持。

## spinlock和信号量sem的区别
重点：死循环/睡眠

spinlock只是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环直到该自旋锁的保持着释放了锁。sem则会导致调用睡眠。然后应用上就是前者可以在中断处理中使用，后者不行。

信号量是针对使用时间比较长的共享资源，而自旋锁的则一般时间比较短。一般的申请锁被其他保存则循环不止的等待。
  spinlock不断的检查等待的对象是否就绪，该进程始终处于执行的状态
  Sem使该进程睡眠，系统会将cpu切换给其他的进程运行
由于这个根本特性的不同，导致了以下用法上的不同：
1.spinlock只适用于短暂的等待，因为没有进程切换所以对于短暂等待他的效率会比较高。但是对于长时间等待，由于占据cpu无法切换，所以不合算
2.spinlock只能在多个cpu的系统中使用，等待者占据cpu，只能由另外一个cpu上的进程释放才能解锁。

两者都是用于Linux内核互斥。避免并发，防止竞争，对系统公共资源或者共有数据进行合理保护的。spinlock的出现是因为
在高并发的地方，轮询比睡眠更高效

semaphore是对一个或多个同类资源的互斥和同步

## 内核态的概念
spinlock与semaphore的主要区别是spin lock是busy waitting，而semaphore是sleep。对于sleep的进程来说，busywaitting当然没有意义。对于单CPU的系统，busywaitting更加没有意义。内核中必须同步执行，不能被打断的需要用到自旋锁。
