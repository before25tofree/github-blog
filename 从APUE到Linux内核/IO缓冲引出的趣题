C库的I/O接口对文件I/O进行了封装，为了提高性能，其引入了缓存机制，共有三种缓存机制：全缓存，行缓存及无缓存
全缓存一般用于访问真正的磁盘文件。C库会为文件访问申请一块内存，只有当文件内容将缓存填满或执行冲刷函数flush时，C库才会将缓存内容写入内核中。
行缓存一般用于访问终端。当遇到一个换行符时，就会引发真正的I/O操作。需要注意的是，C库的行缓存也是固定大小的。因此，当缓存已满，即使没有换行符时也会引发I/O操作。
一个与C库缓存相关的趣题
int main(void)
{
  printf("Hello");
  if(0 == fork()){
    printf("child\n");
    return 0;
  }
  printf("parent\n");
  return 0;
}
因为背后的行缓存，执行fork时，子进程会完全复制父进程的内存空间，因此字符串Hello也存在于子进程的行缓存中。故而最后的输出结果，无论是父进程还是子进程都有Hello字符串。
