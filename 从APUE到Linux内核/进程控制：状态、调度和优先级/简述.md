## 简述进程控制
    就像人不可能一刻不停地工作一样，进程也无法始终占有CPU运行。原因有三
    - 进程可能需要等待某种外部条件的满足，在条件满足之前，进程是无法继续执行的。这种情况下，该进程继续占有CPU就是对CPU资源的浪费。
    - Linux是多用户多任务的操作系统，可能同时存在多个可以运行的进程，进程的个数可能远远多于CPU的个数。一个进程始终占有CPU对其他的进程来说是不公平，进程
    调度器会在合适的时机，选择合适的进程使用CPU资源。
    - Linux进程支持软实时，实时进程的优先级高于普通进程，实时进程之间也有优先级的差别。实时进程之间也有优先级的差别。软实时进程进入可运行状态的时候，可
    能发生抢占，抢占当前运行的进程。
### 进程状态概述
    Linux下，进程的状态有以下7种
      - TASK_RUNNING          // 可运行状态   
      - TASK_INTERRUPTIBLE    // 可被中断的睡眠状态
      - TASK_UNINTERRUPTIBLE  // 不可被中断的睡眠状态
      - TASK_STOPPED          // 暂停状态，进程收到某信号，运行被停止
      - TASK_TRACED           // 被跟踪
      - EXIT_ZOMBIE           // 僵尸状态，进程已经退出但是未被父进程或init进程获取退出状态(PID占用)
      - EXIT_DEAD             // 进程真正的死亡状态
