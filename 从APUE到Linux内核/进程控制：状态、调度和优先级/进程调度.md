## 进程调度概述
    - 进程调度，是任何一个现代操作系统都要解决的问题，它是操作系统相当重要的一个组成部分。首先需要理解的一点是，进程调度器是对于可运行状态的进程进行调度，
    如果进程并非TASK_RUNNING的状态，那么该进程和进程调度是没有关系的。
    - Linux是多任务的操作系统，所谓多任务是指系统能够同时并发地执行多个进程，哪怕是单处理器系统。在单处理器上支持多任务，会给用户多个进程同时跑的幻觉，
    事实上多个进程仅仅是轮流使用CPU资源。只有在多处理。只是在多处理器系统中，多个进程才能真正地做到同时、并行地执行。
    - 多任务系统可以根据是否支持抢占分为两类：非抢占式多任务和抢占式多任务。在非抢占式的多任务系统中，下一个任务被调度的前提是当前进程主动让出CPU的使用
    权，因此非抢占式多任务又称为合作型多任务。而抢占式多任务又操作系统来决定进程调度，在某些时间节点上，操作系统可以将正在运行的进程调度出去，选择其他进
    程来执行。毫无疑问，Linux属于抢占式多任务系统。事实上，大多数的现代操作系统都是抢占式的多任务系统。
      CPU是一种关键的系统资源。在普通PC上CPU的核数，一套合理高效的调度算法就非常重要了。
      此外，不同的进程之间，其行为模式可能存在着巨大的差异。进程的行为模式可以粗略的分为两类：CPU消耗型和I/O消耗型。所谓CPU消耗型是指进程因为没有太多的
    I/O需求，始终处于可运行的状态，始终在执行指令。而I/O消耗型是指进程会有大量的I/O请求，它处于可执行的状态的时间不多，而是将更多的时间耗费在等待上。当
    然这种划分方法并非绝对的，可能有些进程某段时间表现出CPU消耗型的特征，另一段时间又表现出I/O消耗型的特征。
       目前Linux采用的是每个CPU都要有自己的运行队列，即per cpu run queue。每个CPU去自己的运行队列中选择进程，这样就降低了竞争。这种方案还有另外一个好
     处：缓存重利用。某个进程位于这个CPU的运行队列上，经过多次调度之后，内核趋于选择相同的CPU执行该进程。这种情况下上次运行的变量很可能仍然在CPU的缓存中
     这样就提升了效率。
        所有的CPU共用一个运行队列这种方案的弊端是显而易见的，尤其是在CPU数目很多的情况下。
        Linux选择了每一个CPU都有自己的运行队列这种解决方案。这种选择也带来了一种风险：CPU之间负载不均衡，可能出现一些CPU闲着而另外一些CPU忙不过来的情况
      为了解决这个问题，load_balance就登场了。load_balance的任务就是在一定的时机下，通过将任务从一个CPU的运行队列迁移到另一个CPU的运行队列，来保持CPU
      之间负载均衡。
        进程调度具体要做哪些事情呢？概括地说，进程调度的职责就是挑选下一个执行的进程，如果下一个被调度到的进程和调度前运行的进程不是同一个，则执行上下文
      切换，将新选择的进程投入运行。
         Linux是可抢占式内核，从内核2.6版本开始，Linux不仅支持用户态抢占，也开始支持内核态抢占。可抢占式内核的优势在于保证系统的响应时间。当高优先级的
       任务一单就绪，总能及时得到CPU的控制权。但是很明显，内核抢占不能随意发生，某些情况是不允许发生内核抢占的。因此为了更好的支持内核抢占，内核为每一个
       进程的thread_info引入了prempt_count 计数器，数值为0时表示可以抢占，当该计数器的值不为零时，表示禁止抢占。
           并不是所有的时机都允许发生内核抢占。以自旋锁为例，在内核可抢占的系统中，自旋锁持有期间不允许发生内核抢占，否则可能会导致其他CPU长期不能获得锁
       而死等。因此在spin_lock函数中（通过__raw_spin_lock），会调用preempt_disable宏，而该宏会将进程preempt_count计数器的值加1，表示不允许抢占。
       同样的道理，解锁的时候，会将preempt_count的值减1（通过preempt_enable宏）。        
